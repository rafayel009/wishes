<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>A Fading Memory (Final Polish)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
    margin: 0;
    /* Deep dark night gradient */
    background: radial-gradient(circle at 50% 50%, #221a1a, #0a0505 70%, #000000);
    overflow: hidden;
    font-family: "Playfair Display", Georgia, serif;
    height: 100vh;
    width: 100vw;
}

#scene {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    will-change: transform; 
}

canvas { position: absolute; top: 0; left: 0; }

#message {
    position: absolute; right: 5%; top: 45%;
    transform: translateY(-50%); width: 220px;
    text-align: right; color: #e0c3fc;
    opacity: 0; transition: opacity 3s ease-in-out;
    z-index: 10; pointer-events: none;
}

#message p {
    margin: 0 0 1rem 0; line-height: 1.4; font-size: 1.1rem;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
}

#message .signature {
    margin-top: 1.5rem; font-style: italic; opacity: 0.7; font-size: 0.9rem;
}

#curtain {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: #000; opacity: 0; pointer-events: none; z-index: 100;
    transition: opacity 5s ease;
}

@media (max-width: 768px) {
    #message { width: 60%; font-size: 1rem; top: 40%; }
}
</style>
</head>

<body>

<div id="scene">
    <canvas id="bg"></canvas>
    <canvas id="tree"></canvas>
    <canvas id="leaves"></canvas>
</div>

<div id="message">
    <p>Hey…</p>
    <p>I know we don’t talk anymore.</p>
    <p>But some dates are impossible to forget.</p>
    <p>Just wanted to wish you a happy birthday.</p>
    <p class="signature">Hope you’re doing well.</p>
</div>

<div id="curtain"></div>
<img id="leafImg" src="maple-leaf-svgrepo-com.svg" style="display:none">

<script>
// --- PERFORMANCE SETTINGS ---
const MAX_DEPTH = 8;      
const DUST_COUNT = 20;    
const BUSH_COUNT = 50; 

const scene = document.getElementById("scene");
const bg = document.getElementById("bg");
const tree = document.getElementById("tree");
const leavesCanvas = document.getElementById("leaves");
const curtain = document.getElementById("curtain");
const message = document.getElementById("message");
const bctx = bg.getContext("2d");
const ctx = tree.getContext("2d");
const lctx = leavesCanvas.getContext("2d");
const leafImg = document.getElementById("leafImg");

let width, height, groundLevel;
let bushSprites = []; 

function resize() {
    width = innerWidth;
    height = innerHeight;
    bg.width = tree.width = leavesCanvas.width = width;
    bg.height = tree.height = leavesCanvas.height = height;
    groundLevel = height * 0.85;
    
    generateBushSprites(); // Create new bush shapes
    initBushes(); 
}

// --- NEW "SPIKY" BUSH GENERATOR ---
function generateBushSprites() {
    bushSprites = [];
    const types = 5; 
    
    for(let i=0; i<types; i++) {
        const c = document.createElement('canvas');
        const cctx = c.getContext('2d');
        const w = 200;
        const h = 150;
        c.width = w; 
        c.height = h;

        // Dark silhouette color
        cctx.fillStyle = "#0d0d0d"; 
        
        cctx.beginPath();
        // Start bottom left
        cctx.moveTo(0, h);
        
        // Draw "leaves" or spikes
        // We simulate a bush by drawing many triangles/curves radiating from center
        const centerX = w/2;
        const centerY = h;
        const numLeaves = 15 + Math.random() * 10;
        
        for(let j=0; j<=numLeaves; j++) {
            // Angle goes from left (PI) to right (0)
            const angle = Math.PI - (j / numLeaves) * Math.PI;
            
            // Random length for the "leaf" spike
            const len = 40 + Math.random() * 60;
            // Random width of the leaf base
            const leafW = 10 + Math.random() * 10;
            
            // Calculate tip of the leaf
            const tipX = centerX + Math.cos(angle) * len + (Math.random()-0.5)*20;
            const tipY = centerY - Math.sin(angle) * (len * 0.8); // Flatten slightly
            
            // Draw curve to tip and back
            // Using quadratic curves makes them look like organic leaves/grass
            const cp1x = centerX + Math.cos(angle - 0.2) * (len * 0.5);
            const cp1y = centerY - Math.sin(angle - 0.2) * (len * 0.5);
            
            cctx.quadraticCurveTo(cp1x, cp1y, tipX, tipY);
            
            const cp2x = centerX + Math.cos(angle + 0.2) * (len * 0.5);
            const cp2y = centerY - Math.sin(angle + 0.2) * (len * 0.5);
            
            cctx.quadraticCurveTo(cp2x, cp2y, centerX, centerY);
        }
        
        cctx.fill();
        
        // Fill the bottom solid to ensure no gaps
        cctx.beginPath();
        cctx.arc(w/2, h, 40, 0, Math.PI, true);
        cctx.fill();

        bushSprites.push(c);
    }
}

// --- SCENE BUSHES ---
let bushes = [];
function initBushes() {
    bushes = [];
    const treeBaseX = width * 0.25;
    
    for (let i = 0; i < BUSH_COUNT; i++) {
        bushes.push({
            // Spread them out, but cluster more near tree
            x: treeBaseX + (Math.random() - 0.5) * 800, 
            y: groundLevel - 20 + Math.random() * 20, 
            scale: 0.5 + Math.random() * 0.7, 
            type: Math.floor(Math.random() * bushSprites.length), 
            brightness: Math.random() * 10 
        });
    }
    bushes.sort((a, b) => a.y - b.y);
}

resize();
window.addEventListener("resize", resize);

const config = {
    baseGrowSpeed: 0.025, 
    season: 'growing', 
    time: 0
};

let fallTimer = 0;
const FALL_INTERVAL = 8; 

const dust = Array.from({ length: DUST_COUNT }, () => ({
    x: Math.random() * width,
    y: Math.random() * height,
    r: Math.random() * 1.5,
    v: 0.2 + Math.random() * 0.3
}));

const branches = [];
const leaves = [];

function startTree() {
    branches.push({
        x: width * 0.25, 
        // Planted deep so the roots are hidden by bushes
        y: groundLevel + 35, 
        len: height * 0.18, 
        angle: -Math.PI / 2, 
        depth: 0, 
        progress: 0, 
        maxWidth: 26, 
        parentIndex: -1,
        speedRate: 0.9 + Math.random() * 0.2 
    });
}

function updateTree() {
    let growing = false;
    for (let i = 0; i < branches.length; i++) {
        let b = branches[i];
        if (b.progress < 1) {
            b.progress += config.baseGrowSpeed * b.speedRate;
            growing = true;
            if (b.progress >= 0.95 && !b.spawned && b.depth < MAX_DEPTH) {
                b.spawned = true;
                spawnChildren(b, i);
            }
            if (b.progress >= 1 && !b.leafSpawned && b.depth > 1) {
                b.leafSpawned = true;
                if(Math.random() < 0.9) spawnLeaf(b);
            }
        }
    }
    if (!growing && config.season === 'growing') {
        setTimeout(() => {
            config.season = 'falling';
            triggerMessage();
        }, 1000);
    }
}

function spawnChildren(parent, pIndex) {
    const num = Math.random() > 0.3 ? 2 : 1;
    for (let i = 0; i < num; i++) {
        branches.push({
            x: parent.x + Math.cos(parent.angle) * parent.len,
            y: parent.y + Math.sin(parent.angle) * parent.len,
            len: parent.len * (0.65 + Math.random() * 0.2), 
            angle: parent.angle + (Math.random() - 0.5) * 1.4, 
            depth: parent.depth + 1,
            progress: 0,
            maxWidth: parent.maxWidth * 0.7,
            parentIndex: pIndex,
            spawned: false,
            speedRate: 0.9 + Math.random() * 0.2 
        });
    }
}

function drawTree() {
    ctx.clearRect(0, 0, width, height);

    // LAYER 1: BRANCHES (Behind bushes)
    ctx.lineCap = "round";
    for (let i = 0; i < branches.length; i++) {
        let b = branches[i];
        if (b.progress <= 0) continue;
        
        const endX = b.x + Math.cos(b.angle) * b.len * b.progress;
        const endY = b.y + Math.sin(b.angle) * b.len * b.progress;
        
        // Darkened wood color to match the moody scene
        ctx.strokeStyle = `hsl(30, 15%, ${8 + b.depth * 2}%)`;
        ctx.lineWidth = Math.max(1, b.maxWidth * (1 - (b.progress * 0.6)));
        
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();
    }

    // LAYER 2: GROUND
    const gGrad = ctx.createLinearGradient(0, groundLevel, 0, height);
    gGrad.addColorStop(0, "#0a0a0a"); 
    gGrad.addColorStop(1, "#000000"); 
    ctx.fillStyle = gGrad;
    ctx.fillRect(0, groundLevel, width, height - groundLevel);
    
    // LAYER 3: SPIKY BUSHES (In Front)
    if(bushSprites.length > 0) {
        for (let i = 0; i < bushes.length; i++) {
            let b = bushes[i];
            const sprite = bushSprites[b.type];
            const dw = sprite.width * b.scale;
            const dh = sprite.height * b.scale;
            
            // Draw slightly brighter/darker for depth
            // We use globalAlpha to blend them slightly into the dark background
            ctx.globalAlpha = 0.9; 
            ctx.drawImage(sprite, b.x - dw/2, b.y - dh, dw, dh);
            ctx.globalAlpha = 1.0; 
        }
    }
}

function spawnLeaf(branch) {
    const endX = branch.x + Math.cos(branch.angle) * branch.len;
    const endY = branch.y + Math.sin(branch.angle) * branch.len;
    leaves.push({
        x: endX, y: endY, baseX: endX, baseY: endY, size: 0, 
        maxSize: 0.3 + Math.random() * 0.5, 
        angle: Math.random() * Math.PI, attached: true,
        vx: 0, vy: 0, vr: 0, stopped: false
    });
}

function updateLeaves() {
    lctx.clearRect(0, 0, width, height);

    if (config.season === 'falling') {
        fallTimer++;
        if (fallTimer > FALL_INTERVAL) {
            const attached = leaves.filter(l => l.attached);
            if (attached.length > 0) {
                const target = attached[Math.floor(Math.random() * attached.length)];
                target.attached = false;
                target.vx = (Math.random() - 0.5) * 2;
                target.vy = 1 + Math.random();
                target.vr = (Math.random() - 0.5) * 0.05;
            }
            fallTimer = 0; 
        }
    }

    for (let i = 0; i < leaves.length; i++) {
        let l = leaves[i];
        if (l.attached) {
            if (l.size < l.maxSize) l.size += 0.05;
            l.x = l.baseX + Math.sin(config.time * 0.002 + l.baseY) * 3;
            l.y = l.baseY + Math.cos(config.time * 0.002 + l.baseX) * 1;
        } else {
            if (!l.stopped) {
                l.x += l.vx; l.y += l.vy; l.angle += l.vr; l.vy += 0.02; 
                
                // Land inside the new leafy bushes
                // We add some randomness so they don't form a perfect line
                if (l.y > groundLevel - 15 + Math.random() * 25) {
                    l.stopped = true;
                    l.y = groundLevel - 15 + Math.random() * 25;
                }
            }
        }
        lctx.save();
        lctx.translate(l.x, l.y);
        lctx.rotate(l.angle);
        lctx.scale(l.size, l.size);
        if(leafImg.complete && leafImg.naturalHeight !== 0){
             lctx.drawImage(leafImg, -15, -15, 30, 30);
        } else {
             lctx.fillStyle = "#d45d5d"; 
             lctx.beginPath(); lctx.arc(0,0,8,0,Math.PI*2); lctx.fill();
        }
        lctx.restore();
    }
}

function drawBG() {
    bctx.clearRect(0, 0, width, height);
    bctx.fillStyle = "rgba(255,255,255,0.05)";
    for (let i = 0; i < dust.length; i++) {
        let p = dust[i];
        p.y -= p.v;
        if (p.y < 0) p.y = height;
        bctx.beginPath();
        bctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        bctx.fill();
    }
}

function cameraDrift() {
    const dx = Math.sin(config.time * 0.0003) * 15;
    scene.style.transform = `translateX(${dx}px)`; 
}

function triggerMessage() {
    setTimeout(() => {
        message.style.opacity = 1;
        setTimeout(() => {
            curtain.style.opacity = 1;
        }, 8000);
    }, 1500);
}

function loop() {
    config.time += 16;
    drawBG();
    updateTree();
    drawTree();
    updateLeaves();
    cameraDrift();
    requestAnimationFrame(loop);
}

generateBushSprites();
startTree();
loop();
</script>
</body>
</html>
